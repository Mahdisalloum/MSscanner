package com.scanner.WebScanner1;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.net.URLConnection;
import java.util.HashSet;
import java.util.Set;
import org.jsoup.Connection;
import org.jsoup.HttpStatusException;
 
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

@RestController
@SpringBootApplication
public class WebVulnerabilityScanner {

    public static void main(String[] args) {
        SpringApplication.run(WebVulnerabilityScanner.class, args);
    }
    

private String ensureProtocol(String url) {
    if (url.contains("..")) {
        // If the URL contains "..", replace it with an empty string
        url = url.replace("..", "");
    }
    if (!url.startsWith("http://") && !url.startsWith("https://")) {
        // If the URL does not start with "http://" or "https://", prepend "http://"
        url = "http://" + url;
    }
    return url;
}


@PostMapping("/scan/xss")
public ResponseEntity<String> scanForXSS(@RequestBody Map<String, String> requestBody) {
    String url = ensureProtocol(requestBody.get("url"));
    try {
        url = url.replaceAll("\"", ""); // Remove any double quotes from the URL string
        Map<String, String> scanResults = performScan(url, "xss");
        return ResponseEntity.ok(convertToJson(scanResults));
    } catch (Exception e) {
        e.printStackTrace();
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("Error occurred during XSS scan: " + e.getMessage());
    }
}

@PostMapping("/scan/sql-injection")
public ResponseEntity<String> scanForSQLInjection(@RequestBody Map<String, String> requestBody) {
    String url = ensureProtocol(requestBody.get("url"));
    try {
        url = url.replaceAll("\"", ""); // Remove any double quotes from the URL string
        Map<String, String> scanResults = performScan(url, "sql-injection");
        return ResponseEntity.ok(convertToJson(scanResults));
    } catch (Exception e) {
        e.printStackTrace();
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("Error occurred during SQL Injection scan: " + e.getMessage());
    }
}

@PostMapping("/scan/csrf")
public ResponseEntity<String> scanForCSRF(@RequestBody Map<String, String> requestBody) {
    String url = ensureProtocol(requestBody.get("url"));
    try {
        url = url.replaceAll("\"", ""); // Remove any double quotes from the URL string
        Map<String, String> scanResults = performScan(url, "csrf");
        return ResponseEntity.ok(convertToJson(scanResults));
    } catch (Exception e) {
        e.printStackTrace();
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("Error occurred during CSRF scan: " + e.getMessage());
    }
}

private Map<String, String> performScan(String url, String scanType) {
    // Ensure that the URL has the protocol
    url = ensureProtocol(url);
    Map<String, String> scanResults = new HashMap<>();
    try {
        // Check the scanType and invoke the corresponding scanning method
        switch (scanType) {
            case "xss":
                scanResults.put(url, scanForXSS(url));
                break;
            case "sql-injection":
                scanResults.put(url, scanForSQLInjection(url));
                break;
            case "csrf":
                scanResults.put(url, scanForCSRF(url));
                break;
            default:
                // Handle unsupported scan types
                System.err.println("Unsupported scan type: " + scanType);
                break;
        }
    } catch (Exception e) {
        e.printStackTrace();
        // Handle any errors during scanning
    }
    return scanResults;
}

@GetMapping("/crawl-results")
public ResponseEntity<String> getCrawledResults(@RequestParam String url, @RequestParam String scanType) {
    try {
        // Ensure that the URL has the protocol
        url = ensureProtocol(url);
        // Fetch and return crawled results for the specified URL based on the scan type
        String crawledResults = fetchCrawledResults(url, scanType);
        return ResponseEntity.ok(crawledResults);
    } catch (Exception e) {
        e.printStackTrace();
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("Error fetching crawled results: " + e.getMessage());
    }
}


private String fetchCrawledResults(String url, String scanType) {
    try {
        // Fetch HTML content of the target URL without the fragment identifier
        URL baseUrl = new URL(url);
        URLConnection connection = baseUrl.openConnection();
        connection.connect();
        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
        StringBuilder content = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            content.append(line);
        }
        reader.close();

        // Parse the HTML content
        Document doc = Jsoup.parse(content.toString());

        // Extract relevant information from the HTML content
        StringBuilder crawledResults = new StringBuilder();
        crawledResults.append("Crawled Results for ").append(url).append(":\n");

        // Initialize set to store visited links
        Set<String> visitedLinks = new HashSet<>();

        // Extract all links from the HTML content
        Elements links = doc.select("a[href]");
        for (Element link : links) {
            String linkUrl = link.attr("href");
            // Normalize the URL before processing
            String normalizedUrl = normalizeUrl(url, linkUrl);
            // Process the link only if it's not already visited
            if (!visitedLinks.contains(normalizedUrl)) {
                crawlAndScan(normalizedUrl, url, visitedLinks, scanType, crawledResults);
                visitedLinks.add(normalizedUrl); // Add the link to visited set
            }
        }

        // Return the crawled results
        return crawledResults.toString();
    } catch (IOException e) {
        e.printStackTrace();
        return "Error fetching crawled results: " + e.getMessage();
    }
}






private String scanForVulnerability(String targetUrl, String scanType) {
    try {
        // Perform scanning for the specified vulnerability type
        switch (scanType) {
            case "xss":
                return scanForXSS(targetUrl);
            case "sql-injection":
                return scanForSQLInjection(targetUrl);
            case "csrf":
                return scanForCSRF(targetUrl);
            default:
                return "Unsupported scan type: " + scanType;
        }
    } catch (Exception e) {
        e.printStackTrace();
        return "Error occurred during scanning: " + e.getMessage();
    }
}




private void crawlAndScan(String targetUrl, String baseUrl, Set<String> visitedUrls, String scanType, StringBuilder crawledResults) {
    visitedUrls.add(targetUrl); // Add the current URL to visited set

    // Fetch HTML content of the current page
    try {
        Document doc = Jsoup.connect(targetUrl).get();

        // Scan the HTML content for vulnerabilities
        String scanResult = scanForVulnerability(targetUrl, scanType);

        // Append scan result to crawled results
        crawledResults.append("Link: ").append(targetUrl).append("\n");
        crawledResults.append("Scan Result: ").append(scanResult).append("\n\n");

        // Extract links from the HTML content
        Elements links = doc.select("a[href]");
        for (Element link : links) {
            String linkUrl = link.attr("href");
            // Normalize the URL before processing
            String normalizedUrl = normalizeUrl(baseUrl, linkUrl);
            // Process the link only if it's not already visited
            if (!visitedUrls.contains(normalizedUrl)) {
                crawlAndScan(normalizedUrl, baseUrl, visitedUrls, scanType, crawledResults);
            }
        }
    } catch (HttpStatusException e) {
        // Log the HTTP status error
        System.err.println("HTTP error fetching URL. Status=" + e.getStatusCode() + ", URL=" + targetUrl);
        // You can handle the error as needed, such as logging it or ignoring it
    } catch (IOException e) {
        e.printStackTrace();
        // Handle any other IO errors during crawling or scanning
    }
}





    private String convertToJson(Map<String, String> map) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            return mapper.writeValueAsString(map);
        } catch (Exception e) {
            e.printStackTrace();
            // Handle JSON conversion error
            return "{\"error\": \"JSON conversion error\"}";
        }
    }



private String normalizeUrl(String baseUrl, String extractedUrl) {
    try {
        if (extractedUrl.startsWith("http://") || extractedUrl.startsWith("https://")) {
            return extractedUrl;
        }

        // Handle fragments in the URL
        int fragmentIndex = extractedUrl.indexOf('#');
        String baseUrlWithoutFragment = (fragmentIndex != -1) ? extractedUrl.substring(0, fragmentIndex) : extractedUrl;

        // Handle "../" in the extractedUrl
        if (baseUrlWithoutFragment.startsWith("../")) {
            // Remove the leading "../"
            String normalizedUrl = baseUrlWithoutFragment.substring(3);
            // Resolve against the base URL to handle relative paths correctly
            URL base = new URL(baseUrl);
            URL absolute = new URL(base, normalizedUrl);
            return absolute.toString();
        }

        extractedUrl = URLDecoder.decode(extractedUrl, StandardCharsets.UTF_8.toString());
        URL base = new URL(baseUrl);
        URL absolute = new URL(base, extractedUrl);
        return absolute.toString();
    } catch (MalformedURLException | UnsupportedEncodingException e) {
        e.printStackTrace();
        return null;
    }
}





  public static String scanForXSS(String targetUrl) {
        String[] xssPayloads = {
            "<script>alert('XSS')</script>",
            "'\"><script>alert('XSS')</script>",
            "\"><script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>"
        };

        StringBuilder result = new StringBuilder();
        result.append("Started XSS scan at: ").append(targetUrl).append("\n");

        try {
            boolean searchFormDetected = isFormPresent(targetUrl, "search");
            boolean commentFormDetected = isFormPresent(targetUrl, "comment");

            if (!searchFormDetected && !commentFormDetected) {
                result.append(" No search or comment form detected. Trying to scan the login username and password inputs.\n");

                for (String payload : xssPayloads) {
                    String usernameVulnerableUrl = targetUrl + "?username=" + URLEncoder.encode(payload, StandardCharsets.UTF_8.name());
                    String passwordVulnerableUrl = targetUrl + "?password=" + URLEncoder.encode(payload, StandardCharsets.UTF_8.name());

                    scanInputForXSS(usernameVulnerableUrl,payload, result);
                    scanInputForXSS(passwordVulnerableUrl,payload, result);
                }
            } else {
                if (searchFormDetected) {
                    result.append(" Search form detected. Scanning search input.\n");

                    for (String payload : xssPayloads) {
                        String searchVulnerableUrl = targetUrl + "?search=" + URLEncoder.encode(payload, StandardCharsets.UTF_8.name());
                        scanInputForXSS(searchVulnerableUrl,payload, result);
                    }
                }

                if (commentFormDetected) {
                    result.append(" Comment form detected. Scanning comment input.\n");

                    for (String payload : xssPayloads) {
                        String commentVulnerableUrl = targetUrl + "?comment=" + URLEncoder.encode(payload, StandardCharsets.UTF_8.name());
                        scanInputForXSS(commentVulnerableUrl, payload ,result);
                    }
                }
            }
        } catch (Exception e) {
            result.append("[-] Error occurred while scanning: ").append(e.getMessage()).append("\n");
            e.printStackTrace();
        }

        return result.toString();
    }

    private static boolean isFormPresent(String targetUrl, String inputName) {
        try {
            HttpURLConnection connection = (HttpURLConnection) new URL(targetUrl).openConnection();
            connection.setRequestMethod("GET");

            int responseCode = connection.getResponseCode();
            if (responseCode == HttpURLConnection.HTTP_OK) {
                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                String inputLine;
                StringBuilder response = new StringBuilder();
                while ((inputLine = in.readLine()) != null) {
                    response.append(inputLine);
                }
                in.close();

                return response.toString().contains("<input") && response.toString().contains(inputName);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return false;
    }

private static void scanInputForXSS(String vulnerableUrl, String payload, StringBuilder result) {
    try {
        HttpURLConnection connection = (HttpURLConnection) new URL(vulnerableUrl).openConnection();
        connection.setRequestMethod("GET");

        int responseCode = connection.getResponseCode();
        if (responseCode == HttpURLConnection.HTTP_OK) {
            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            String inputLine;
            StringBuilder response = new StringBuilder();
            while ((inputLine = in.readLine()) != null) {
                response.append(inputLine);
            }
            in.close();

            // Check if the response body contains the injected payload (e.g., JavaScript popup)
            if (response.toString().contains(payload)) {
                result.append("[+] XSS payload injected but no alert shown at: ").append(vulnerableUrl).append("\n");
            } else {
                result.append("[-] No XSS vulnerability found at: ").append(vulnerableUrl).append("\n");
            }
        } else {
            // Non-OK response codes indicate injection failure
            result.append("[-] Injection attempt failed at: ").append(vulnerableUrl).append(" (HTTP ").append(responseCode).append(")\n");
        }
    } catch (IOException e) {
        // Handle connection errors or exceptions
        result.append("[-] Error occurred while scanning URL ").append(vulnerableUrl).append(": ").append(e.getMessage()).append("\n");
    }
}




public static String scanForSQLInjection(String targetUrl) {
        String[] payloads = {
                "' OR 1=1 #",
                "admin' or '1'='1'/*",
                "admin' or '1'='1",
                "or 1=1#",
                "admin' or 1=1#",
                "admin') or '1'='1'#",
                "'; DROP TABLE users; #",
                "1' OR '1'='1",
                " ORDER BY 1# ",
                "' OR '1'='1",
                "' OR 1=1 --",
                "QUERY-1-HERE; QUERY-2-HERE"
                // Add more payloads as needed
        };

        StringBuilder result = new StringBuilder();
        result.append("Started SQL Injection scan at: ").append(targetUrl).append("\n");

        try {
            Document doc = Jsoup.connect(targetUrl).get();
            Elements forms = doc.select("form");

            if (forms.isEmpty()) {
                result.append("No forms detected on the page.\n");
                return result.toString();
            }

            for (Element form : forms) {
                Elements emailInputs = form.select("input[type=email], input[name=email]");
                Elements passwordInputs = form.select("input[type=password], input[name=password]");
                Elements searchInputs = form.select("input[type=text], input[name=search]");

                if (!emailInputs.isEmpty() && !passwordInputs.isEmpty()) {
                    result.append("Login form detected. Scanning email and password inputs.\n");
                    scanEmailAndPassword(targetUrl, emailInputs, passwordInputs, payloads, result);
                } else if (!searchInputs.isEmpty()) {
                    result.append("Search form detected. Scanning search input.\n");
                    scanSearchInputs(targetUrl, searchInputs, payloads, result);
                } else {
                    result.append("No email, password, or search inputs detected on the form.\n");
                }
            }
        } catch (IOException e) {
            result.append("[-] Error occurred while scanning: ").append(e.getMessage()).append("\n");
        }
        return result.toString();
    }

    private static void scanEmailAndPassword(String targetUrl, Elements emailInputs, Elements passwordInputs, String[] payloads, StringBuilder result) throws IOException {
        for (Element emailInput : emailInputs) {
            String emailInputName = emailInput.attr("name");
            for (Element passwordInput : passwordInputs) {
                String passwordInputName = passwordInput.attr("name");

                for (String payload : payloads) {
                    String vulnerableUrl = targetUrl + "?" +
                            emailInputName + "=" + URLEncoder.encode(payload, StandardCharsets.UTF_8.name()) +
                            "&" + passwordInputName + "=" + URLEncoder.encode("randomPassword123", StandardCharsets.UTF_8.name());
                    scanInput(vulnerableUrl, result, emailInputName, passwordInputName);
                }
            }
        }
    }

    private static void scanSearchInputs(String targetUrl, Elements searchInputs, String[] payloads, StringBuilder result) throws IOException {
        for (Element searchInput : searchInputs) {
            String searchInputName = searchInput.attr("name");

            for (String payload : payloads) {
                String vulnerableUrl = targetUrl + "?" + searchInputName + "=" + URLEncoder.encode(payload, StandardCharsets.UTF_8.name());
                scanInput(vulnerableUrl, result, searchInputName, null);
            }
        }
    }

private static void scanInput(String vulnerableUrl, StringBuilder result, String inputName, String otherInputName) {
    try {
        
        Document doc = Jsoup.connect(vulnerableUrl).get();
        Element form = doc.selectFirst("form");

        if (form != null) {
            Map<String, String> formData = new HashMap<>();
            for (Element input : form.select("input")) {
                String name = input.attr("name");
                if (!name.isEmpty()) {
                    if (name.equals(inputName)) {
                        formData.put(name, "payload");  // Inject payload here
                    } else if (otherInputName != null && name.equals(otherInputName)) {
                        formData.put(name, "randomPassword123");
                    } else {
                        formData.put(name, input.val());
                    }
                }
            }
            
            // Find the login button and simulate clicking it
            Elements loginButton = form.select("button[type=submit], input[type=submit]");
            if (!loginButton.isEmpty()) {
                // Submit the form by clicking the login button
                formData.put(loginButton.first().attr("name"), loginButton.first().val());
            }

            String formAction = form.attr("action");
            String formMethod = form.attr("method").toUpperCase();
            String actionUrl = formAction.isEmpty() ? vulnerableUrl : new URL(new URL(vulnerableUrl), formAction).toString();

            Connection connectionSubmit = Jsoup.connect(actionUrl)
                    .data(formData)
                    .method("POST".equals(formMethod) ? Connection.Method.POST : Connection.Method.GET);

            Connection.Response response = connectionSubmit.execute();

            Document responseDoc = response.parse();
            String responseText = responseDoc.text();
            if (responseText.toLowerCase().contains("incorrect email") || responseText.toLowerCase().contains("incorrect password") || responseText.toLowerCase().contains("login") || responseText.toLowerCase().contains("email") || responseText.toLowerCase().contains("password")) {
                result.append("[-] ").append(actionUrl)
                        .append(" in input: ").append(inputName);
                if (otherInputName != null) {
                    result.append(" and ").append(otherInputName);
                }
                result.append("\n");
            } else {
                result.append("[+]").append(actionUrl)
                        .append(" in input: ").append(inputName);
                if (otherInputName != null) {
                    result.append(" and ").append(otherInputName);
                }
                result.append("\n");
            }
        } else {
            result.append("[-] No form found at: ").append(vulnerableUrl).append("\n");
        }
    } catch (IOException e) {
        result.append("[-]").append(vulnerableUrl).append(": ").append(e.getMessage()).append("\n");
    }
}







private static String scanForCSRF(String targetUrl) {
    int maxRetries = 3;
    StringBuilder result = new StringBuilder();
    result.append(" Started CSRF scan at: ").append(targetUrl).append("\n");
    for (int i = 0; i < maxRetries; i++) {
        try {
            URL url = new URL(targetUrl);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("GET");
            connection.setConnectTimeout(5000);
            connection.setReadTimeout(10000);
            int responseCode = connection.getResponseCode();
            if (responseCode == HttpURLConnection.HTTP_OK) {
                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                String inputLine;
                StringBuilder response = new StringBuilder();
                while ((inputLine = in.readLine()) != null) {
                    response.append(inputLine);
                }
                in.close();
                if (response.toString().contains("csrf_token")) {
                    result.append("[+] CSRF protection mechanism detected at: ").append(targetUrl).append("\n");
                } else {
                    result.append("[-] No CSRF protection mechanism detected.").append("\n");
                }
                break;
            } else {
                result.append("HTTP error ").append(responseCode).append(" while scanning for CSRF at: ").append(targetUrl).append("\n");
            }
        } catch (IOException e) {
            result.append("Error occurred while scanning for CSRF: ").append(e.getMessage()).append("\n");
        }
        try {
            Thread.sleep(1000);
        } catch (InterruptedException ex) {
            Thread.currentThread().interrupt();
        }
    }
    return result.toString();
}
}